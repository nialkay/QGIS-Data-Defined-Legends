# -*- coding: utf-8 -*-
"""
/***************************************************************************
 xDialog
                                 A QGIS plugin
 uyuy
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-05-28
        git sha              : $Format:%H$
        copyright            : (C) 2022 by uyuy
        email                : uyuy
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import *
from qgis.core import *
from qgis.gui import *
from qgis.utils import iface
from PyQt5.Qt import *
from .qgis_legend import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'uyuy_dialog_base.ui'))


class xDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(xDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # Set initial conditions for top level
        self.vector_layers.setFilters(QgsMapLayerProxyModel.PointLayer|QgsMapLayerProxyModel.LineLayer)
        self.information_label.setWordWrap(True)
        self.variant_selector.setTabVisible(0, True)
        self.variant_selector.setTabVisible(1, False)
        self.variant_selector.setTabVisible(2, False)

        self.vector_layers.layerChanged.connect(lambda: self.read_layer(self.vector_layers.currentLayer()))

        try:
            self.create_legend.clicked.connect(self.execute_create_legend)
        except:
            pass

        # Set initial conditions for single variant tab
        self.field_names.setEnabled(False)
        self.legend_text_every.setMinimum(1)
        self.legend_item_count.setMinimum(2)
        self.decimal_places.setMaximum(5)
        self.min_value.setValidator(QDoubleValidator(-999999, 999999, 5, self))
        self.max_value.setValidator(QDoubleValidator(-999999, 999999, 5, self))

        self.get_min_max.clicked.connect(lambda: self.execute_get_min_max(self.vector_layers.currentLayer(), self.field_names.currentField(), self.min_value, self.max_value))

        # Set initial conditions for double variant size tab
        self.field_names_2.setEnabled(False)
        self.legend_text_every_2.setMinimum(1)
        self.legend_item_count_2.setMinimum(2)
        self.decimal_places_2.setMaximum(5)
        self.min_value_2.setValidator(QDoubleValidator(-999999, 999999, 5, self))
        self.max_value_2.setValidator(QDoubleValidator(-999999, 999999, 5, self))

        self.get_min_max_2.clicked.connect(lambda: self.execute_get_min_max(self.vector_layers.currentLayer(), self.field_names_2.currentField(), self.min_value_2, self.max_value_2))

        # Set initial conditions for double variant colour tab
        self.field_names_3.setEnabled(False)
        self.legend_text_every_3.setMinimum(1)
        self.legend_item_count_3.setMinimum(2)
        self.decimal_places_3.setMaximum(5)
        self.min_value_3.setValidator(QDoubleValidator(-999999, 999999, 5, self))
        self.max_value_3.setValidator(QDoubleValidator(-999999, 999999, 5, self))
        self.legend_item_size_3.setValidator(QDoubleValidator(-999999, 999999, 2, self))

        self.get_min_max_3.clicked.connect(lambda: self.execute_get_min_max(self.vector_layers.currentLayer(), self.field_names_3.currentField(), self.min_value_3, self.max_value_3))


    def read_layer(self, vlayer):
        # This function first finds whether our layer has the correct renderer type.
        # If it is, read the layer symbology, including data defined information.
        if vlayer.renderer().type() != 'singleSymbol':
            self.information_label.setText('Chosen layer does not have Single Symbol renderer, please choose another.')
        else:
            layer_params = read_vector_symbology(vlayer)
            self.variant_selector.setTabVisible(0, True)
            self.variant_selector.setTabVisible(1, False)
            self.variant_selector.setTabVisible(2, False)

            # Check what type of overrides are in place.
            # First, if not overrides are in place in the layer, tell the user and do nothing more.
            if 'colour_field' not in layer_params.keys() and 'size_field' not in layer_params.keys():
                self.information_label.setText('Chosen layer does not have any data defined overrides, please choose another.')
            # Size field
            elif 'colour_field' not in layer_params.keys():
                self.information_label.setText('')
                self.field_names.setLayer(vlayer)
                self.field_names.setField(layer_params['size_field'])
                self.execute_get_min_max(vlayer, self.field_names.currentField(), self.min_value, self.max_value)
            # Colour field
            elif 'size_field' not in layer_params.keys():
                self.information_label.setText('')
                self.field_names.setLayer(vlayer)
                self.field_names.setField(layer_params['colour_field'])
                self.execute_get_min_max(vlayer, self.field_names.currentField(), self.min_value, self.max_value)
            # The colour field and size field both have overrides, but use the same field.
            elif layer_params['colour_field'] == layer_params['size_field']:
                self.information_label.setText('')
                self.field_names.setLayer(vlayer)
                self.field_names.setField(layer_params['size_field'])
                self.execute_get_min_max(vlayer, self.field_names.currentField(), self.min_value, self.max_value)
            # Both the size field and the colour field have overrides, but use a different field.
            else:
                self.information_label.setText('')
                self.variant_selector.setTabVisible(0, False)
                self.variant_selector.setTabVisible(1, True)
                self.variant_selector.setTabVisible(2, True)
                self.field_names_2.setLayer(vlayer)
                self.field_names_3.setLayer(vlayer)
                self.field_names_2.setField(layer_params['size_field'])
                self.field_names_3.setField(layer_params['colour_field'])
                self.execute_get_min_max(vlayer, self.field_names_2.currentField(), self.min_value_2, self.max_value_2)
                self.execute_get_min_max(vlayer, self.field_names_3.currentField(), self.min_value_3, self.max_value_3)


    def execute_get_min_max(self, selected_layer, selected_field, min_text, max_text):
        # This function finds the minimum and maximum values in the field of the layer.
        # 'min_text' and 'max_text' are text boxes that hold the respective values.
        min, max = find_min_max(selected_layer, selected_field)
        min_text.setText(str(min))
        max_text.setText(str(max))


    def execute_create_legend(self):
        # This function gets the parameters from all the inputs and runs the 'process_data_defined' to create our legends.
        selected_layer = self.vector_layers.currentLayer()
        # If we have a warning message, do not execute the rest of the code.
        if self.information_label.text() != '':
            return
        # If the first tab is visible, then we have one data defined override field. We are creating only one legend.
        if self.variant_selector.isTabVisible(0):
            selected_field = self.field_names.currentField()
            steps = self.legend_item_count.value()
            legend_every = self.legend_text_every.value()
            decimal_places = self.decimal_places.value()
            # Get the inputs from the min and max text boxes. If somehow blank, run the required function to get values.
            try:
                min = float(self.min_value.text())
                max = float(self.max_value.text())
            except:
                min, max = find_min_max(selected_layer, selected_field)
                min = float(min)
                max = float(max)

            parameters = {'layer': selected_layer,
                          'single_or_double_variant': 'single',
                          'field_1': {'title': selected_layer.name() + ' ' + selected_field + ' Legend',
                                      'fname': selected_field,
                                      'min': min,
                                      'max': max,
                                      'steps': steps,
                                      'legend_occurrence': legend_every,
                                      'decimal_places': decimal_places,
                                      'override': {'type': ''}
                                      }
                            }
        # If the first tab is not visible, we have a dual variable legend.
        # The general principal is the same, except we collect values from two different sets of inputs.
        else:
            selected_field = self.field_names_2.currentField()
            steps = self.legend_item_count_2.value()
            legend_every = self.legend_text_every_2.value()
            decimal_places = self.decimal_places_2.value()

            try:
                min = float(self.min_value_2.text())
                max = float(self.max_value_2.text())
            except:
                min, max = find_min_max(selected_layer, selected_field)
                min = float(min)
                max = float(max)

            try:
                colour = self.legend_colour_2.color()
                colour_str = str(colour.red()) + ',' + str(colour.green()) + ',' + str(colour.blue()) + ',' + str(colour.alpha())
            except:
                colour_str = '128,128,128,255'

            field_1 = { 'title': selected_layer.name() + ' ' + selected_field + ' Legend',
                        'fname': selected_field,
                        'min': min,
                        'max': max,
                        'steps': steps,
                        'legend_occurrence': legend_every,
                        'decimal_places': decimal_places,
                        'override': {'type': 'colour',
                                     'value': colour_str}
                        }

            selected_field = self.field_names_3.currentField()
            steps = self.legend_item_count_3.value()
            legend_every = self.legend_text_every_3.value()
            decimal_places = self.decimal_places_3.value()

            try:
                min = float(self.min_value_3.text())
                max = float(self.max_value_3.text())
            except:
                min, max = find_min_max(selected_layer, selected_field)
                min = float(min)
                max = float(max)

            try:
                size = float(self.legend_item_size_3.text())
            except:
                size = 0

            field_2 = { 'title': selected_layer.name() + ' ' + selected_field + ' Legend',
                        'fname': selected_field,
                        'min': min,
                        'max': max,
                        'steps': steps,
                        'legend_occurrence': legend_every,
                        'decimal_places': decimal_places,
                        'override': {'type': 'size',
                                     'value': size}
                        }
            parameters = {'layer': selected_layer,
                          'single_or_double_variant': 'double',
                          'field_1': field_1,
                          'field_2': field_2
                          }
        process_data_defined(parameters)
